# Analysis of Russian River Estuary Data

```{r include = FALSE}
require(rremat)
require(ggplot2)
require(knitr)
require(dplyr)
opts_chunk$set(fig.width = 12, fig.height = 8, echo = FALSE)
```

## Closure referencing

The code below adds a reference to CTD transect dates indicating the closure ID
associated with the transect and the number of days since closure began. In 
this analysis, closures are identified based on the photographic record.

```{r calc-days}
data(closures)
data(ctd)
closurecol = "closure.id"
durationcol = "days.since"
ctd[closurecol] = NA
ctd[durationcol] = NA
for(i in seq(nrow(closures))){
  idmask = ctd$date > closures$initiation[i] & ctd$date < closures$breach[i]
  ctd[idmask, closurecol] = closures$id[i]
  ctd[idmask, durationcol] = ctd[idmask, "date"] - closures$initiation[i]
}
```

## Constriction index

The constriction index is intended to provide an indicator of the degree of 
mouth constriction/closure.

```{r calc-ranges}
data(tides)
tiderange = summarize(group_by(tides, datetime = as.Date(datetime)), 
  min = min(height), max = max(height), range = max - min)
data(wll)
rrerange = summarize(group_by(subset(wll, site == "river mouth"), 
  mtime = as.Date(mtime)), min = min(depth), max = max(depth), 
  range = max - min)

ggplot(tiderange, aes(x = datetime, y = range)) + geom_point()
dev.new()
ggplot(rrerange, aes(x = mtime, y = range)) + geom_point()  

ggplot(tail(subset(wll, site == "river mouth"), 10000), aes(x = mtime, y = depth)) + geom_line()
  
data(ctdmeta)
rreratio = data.frame(date = as.Date(ctdmeta$start), note = ctdmeta$note,
  rrerange = NA, tiderange = NA)
for(i in seq(nrow(rreratio))){
  thisdate = rreratio$date[i]
  if(thisdate %in% rrerange$mtime)
    rreratio[i, "rrerange"] = rrerange[rrerange$mtime == thisdate, "range"]
  if(thisdate %in% tiderange$datetime)
    rreratio[i, "tiderange"] = tiderange[tiderange$datetime == thisdate, "range"]
}  
rreratio["ci"]= rreratio$tiderange/rreratio$rrerange
```  

## Extraction of surface and bottom-layer data

```{r get-surface}
surfdepth = 0.75
surface = summarize(group_by(ctd, date, dist), 
  ta = spline(depth, ta, xout = surfdepth)$y,
  sa = spline(depth, sa, xout = surfdepth)$y,
  oa = spline(depth, oa, xout = surfdepth)$y)  

bottomdepth = 5.0
bottom = summarize(group_by(ctd, date, dist), 
  maxdepth = max(depth),
  ta = spline(depth, ta, xout = bottomdepth)$y,
  sa = spline(depth, sa, xout = bottomdepth)$y,
  oa = spline(depth, oa, xout = bottomdepth)$y)  
bottom[bottom$maxdepth < bottomdepth, c("ta", "sa", "oa")] = NA

cline = summarize(group_by(ctd, date, dist),
  ta.cline = depth[min(which(diff(diff(ta)) == max(diff(diff(ta)))))],
  sa.cline = depth[min(which(diff(diff(sa)) == max(diff(diff(sa)))))],
  oa.cline = depth[min(which(diff(diff(oa)) == max(diff(diff(oa)))))],
  blt = abs(ta.cline - sa.cline))
```

## K-means clustering analysis

pamk(surf[c("ta", "sa", "oa")], scaling = TRUE)




